<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on Home</title>
    <link>https://studymakesmehappy.club/categories/security/</link>
    <description>Recent content in Security on Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 27 Jul 2019 17:13:56 +0800</lastBuildDate>
    
	<atom:link href="https://studymakesmehappy.club/categories/security/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两步验证器是如何工作的</title>
      <link>https://studymakesmehappy.club/posts/%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</link>
      <pubDate>Sat, 27 Jul 2019 17:13:56 +0800</pubDate>
      
      <guid>https://studymakesmehappy.club/posts/%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</guid>
      <description>当今一个互联网账号，几乎包含了你所有的信息。一位 Google 的重度用户，会上传他的照片、文件、通讯录、Docs、密码、浏览记录、搜索记录等，一个账号行走天下。虽然很方便，但随之而来的安全隐患就必须引起重视了。我们已经厌烦了各种照片泄漏事件了，对吧？
记住，密码总是不安全的，为了牢牢地保护好账号，开启两步验证(2FA)是一个好主意。两步验证开启之后，在输入正确的账号和密码之后，需要一步额外的信息验证，比如短信验证码、邮件验证码。
可每次打开手机、邮箱查看验证码多麻烦啊，短信有延迟、邮件会进垃圾邮件，再说也不是很安全。账号服务商为了方便用户登陆，会推出相应的两步验证器，比如 Google Authenticator 和 Microsoft Authenticator 等，相信不少用户都听过或用过。两步验证器会提供给你一个神秘代码，一般是6位或者8位数字，有效期一般为30s，可以用它作为额外的安全信息。
有趣的是，一个两步验证器，可以支持多个不同的账号。比如我的验证器里有 Microsoft, Google, Github 和 Firefox 的账号。在登陆的时候，在网页中填入相应的神秘代码就好。（注意下图中的代码和上图中并不一致，因为是在不同时间截的图啦。）
更神奇的是，两步验证器即使在离线（断网）的情况下，也能正常工作。这就很有意思啦，好奇的同学一定会思考，“6位或8位、30s、多账号通用、断网也能用”，这冥冥之中一定意味着什么。宇宙的奥秘？人生的意义？还是那通往一切的终极答案？别瞎想啦，少年，今天我就带你揭开两步验证器的神秘面纱。
猜想 让我们做一些猜想：
 断网也能用，说明验证器客户端和认证服务器之间没有数据传输。没有通信的情况下，验证器产生的数字，可以通过服务器的认证，说明服务器也产生了一样的数字 有效期一般为30s，说明产生数字这个计算的一个变量是当前时间，每30s为一个窗口。 在同一个时间窗口下，不同的账号产生了不同的数字，说明这个计算还有一个变量是和账号有关的。这个账号相关的变量是什么还不确定，我们通过设置 Github 两步验证来研究一下。  使用验证器扫描 Github 服务器生成的二维码（这里做了马赛克处理），验证器立马就能产生一个6位数字，然后在下方输入这个数字，验证一下，和服务器建立同步。看来关键是，二维码中的数据是什么？我提取之后，发现它长下面这样
# easy-pieces 是我为这篇文章注册的 Github 小号的用户名 # secret 是 Github 生成的 secret，出于安全考虑，这里用了伪 secret otpauth://totp/GitHub:easy-pieces?secret=iamapseudosecret&amp;amp;issuer=GitHub 可以发现关键就是用户名和 secret，由于 secret 已经能唯一代表一个账号，但用户名不一定能（不同账号可以有同样的用户名）唯一代表一个账号，所以 secret 就是生成6位数字所依赖的变量。
生成这个数字的公式可以表示为：
number = f(current_datetime, secret) 总结一下：
 验证器客户端和服务器首先通过二维码，协商出一个 secret，然后各自保存 在用户登录的时候，打开验证器，验证器会根据当前时间窗口以及之前协商好的 secret，算出一个数字 用户手动输入这个数字，传输到服务器 服务器使用同样的函数，算出一个数字，判断与用户输入的数字是否匹配  这就是两步验证器的基本原理。这里提一个问题供大家思考：
当使用验证器扫描二维码的时候，验证器有没有向服务器通信？如果没有，服务器如何确认客户端已经扫了二维码，从而开始同步计算？ 接下来我会介绍一下背后的 RFC 标准，涉及函数 f 的定义、时间窗口如何计算、安全问题等、如果不感兴趣，可以跳过。</description>
    </item>
    
  </channel>
</rss>